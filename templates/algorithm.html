<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Алгоритм Прима</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style_alg.css') }}">
</head>
<body>
    <h2>Алгоритм Прима</h2>


<h3>1.1. Основные определения</h3>

<p>Алгоритм Прима – это алгоритм поиска минимального остовного дерева в взвешенном графе, открытый американским математиком Робертом Примом в 1957 году.</p>

<p>Поддерево — это набор рёбер, соединяющих все вершины, причём из любой вершины можно добраться до любой другой ровно одним простым путём. Поддерево содержит (n – 1) вершин.
    Минимальное остовное дерево (минимальный остов) – это такое поддерево графа, сумма весов ребер которого минимальна.</p>

    <h3>1.2. Свойства минимальных остовов</h3>

    <p>Максимальный остов также можно искать алгоритмом Прима (например, заменив все веса рёбер на противоположные: алгоритм не требует неотрицательности весов рёбер).</p>
    <p>	Минимальный остов единственен, если веса всех рёбер различны. В противном случае, может существовать несколько минимальных остовов.</p>
    <p>Минимальный остов также является остовом, минимальным по произведению всех рёбер (предполагается, что все веса положительны).</p>

    <h3>1.3. Описание алгоритма</h3>

    <p>Изначально остов полагается состоящим из единственной вершины (её можно выбрать произвольно). Затем выбирается ребро минимального веса, исходящее из этой вершины, и добавляется в минимальный остов. После этого остов содержит уже две вершины, и теперь ищется и добавляется ребро минимального веса, имеющее один конец в одной из двух выбранных вершин, а другой — наоборот, во всех остальных, кроме этих двух. И так далее, т.е. всякий раз ищется минимальное по весу ребро, один конец которого — уже взятая в остов вершина, а другой конец — ещё не взятая, и это ребро добавляется в остов (если таких рёбер несколько, можно взять любое). Этот процесс повторяется до тех пор, пока остов не станет содержать все вершины.</p>

    <h3>1.4. Доказательство</h3>

    <p>Пусть граф G был связным, т.е. ответ существует. Обозначим через T остов, найденный алгоритмом Прима, а через S — минимальный остов. Очевидно, что T действительно является остовом (т.е. поддеревом графа G). Покажем, что веса S и T совпадают.</p>

    <p>Рассмотрим первый момент времени, когда в T происходило добавление ребра, не входящего в оптимальный остов S. Обозначим это ребро через e, концы его — через a и b, а множество входящих на тот момент в остов вершин — через V (согласно алгоритму, a ∈ V, b ∉ V, либо наоборот). В оптимальном остове S вершины a и b соединяются каким-то путём P; найдём в этом пути любое ребро g, один конец которого лежит в V, а другой — нет. Поскольку алгоритм Прима выбрал ребро e вместо ребра g, то это значит, что вес ребра g больше либо равен весу ребра e.</p>

    <p>Удалим теперь из S ребро g, и добавим ребро e. По только что сказанному, вес остова в результате не мог увеличиться (уменьшиться он тоже не мог, поскольку S было оптимальным). Кроме того, S не перестало быть остовом (в том, что связность не нарушилась, нетрудно убедиться: мы замкнули путь P в цикл, и потом удалили из этого цикла одно ребро).</p>

    <p>Итак, мы показали, что можно выбрать оптимальный остов S таким образом, что он будет включать ребро e. Повторяя эту процедуру необходимое число раз, мы получаем, что можно выбрать оптимальный остов S так, чтобы он совпадал с T. Следовательно, вес построенного алгоритмом Прима T минимален, что и требовалось доказать.</p>

    <h3>1.5. Различные виды реализации и их сложность</h3>

    <p>Существует 2 вида стандартной реализации алгоритма Прима:</p>
    <p>
        <p>1. Перебор весов ребер вершины среди всех возможных вариантов. Для этого будет требоваться просмотр O(m) рёбер, чтобы найти среди всех допустимых ребро с наименьшим весом. Суммарная асимптотика алгоритма составит в таком случае O(nm).</p>
        <p>2. Улучшенная версия данного алгоритма, в которой просматриваются каждый раз не все рёбра, а только по одному ребру из каждой уже выбранной вершины. Для этого требуется выполнить сортировку рёбер каждый вершина по возрастанию весов, тогда достаточно будет хранить только первый элемент отсортированного списка. Общая сложность алгоритма (с сортировкой): O(n^2+m log⁡n). Именно эта версия реализации алгоритма используется в программе.</p>
    </p>

    <a href="generation"><h2>Сгенерировать граф</h2></a>
</body>
</html>